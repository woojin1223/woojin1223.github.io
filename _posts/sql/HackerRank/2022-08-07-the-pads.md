---
title: "[HackerRank] The PADS"
categories: SQL
tags: [HackerRank, MySQL]
---

## 문제 링크

<https://www.hackerrank.com/challenges/the-pads/problem>

<br><br><br><br>

## 테이블 설명

### `Occupations`

`Occupations`는 사람의 이름과 직업이 있는 테이블이다.

(열 설명)

- `Name`: 이름에 해당한다.
- `Occupation`: 직업명에 해당한다.

(예시)

|Name|Occupation|
|:-:|:-:|
|Samantha|Doctor|
|Julia|Actor|
|Maria|Actor|
|Meera|Singer|
|Ashely|Professor|
|Ketty|Professor|
|Christeen|Professor|
|Jane|Actor|
|Jenny|Doctor|
|Priya|Singer|

<br><br><br><br>

## 문제 설명

아래의 두 테이블을 만드는 문제다.

### 1. 직업명의 첫 글자를 괄호로 씌워 이름의 바로 오른쪽에 붙인 문자열 (테이블1)

- 단, 알파벳 문자 기준으로 오름차순 정렬해야 한다.

(예시)

|result|
|:-:|
|Ashely(P)|
|Christeen(P)|
|Jane(A)|
|Jenny(D)|
|Julia(A)|
|Ketty(P)|
|Maria(A)|
|Meera(S)|
|Priya(S)|
|Samantha(D)|

### 2. 각 직업별 빈도에 대한 문자열 (테이블2)

- 형식은 `There are a total of [occupation_count] [occupation]s.`
- [occupation_count]는 직업의 빈도, [occupation]은 직업명을 전부 소문자로 변환한 문자열
- 단, [occupation_count], [occupation] 기준으로 오름차순 정렬해야 한다.

(예시)

|result|
|:-:|
|There are a total of 2 doctors.|
|There are a total of 2 singers.|
|There are a total of 3 actors.|
|There are a total of 3 professors.|

<br><br><br><br>

## 사고 과정

### 1. 테이블1을 만든다.

직업명의 첫 글자를 괄호로 씌워 이름의 바로 오른쪽에 붙인 문자열을 `CONCAT(name, '(', LEFT(occupation, 1), ')')`으로 구한 다음 `result` 열에 저장하자.  
그리고 테이블1과 테이블2를 구분하기 위해 테이블1에 해당하는 행은 전부 1을 가지는 `table_type` 열을 만든다.

```sql
SELECT 
    CONCAT(name, '(', LEFT(occupation, 1), ')') AS result, 
    1 AS table_type 
FROM 
    occupations 
```

(출력)

|result|table_type|
|:-:|:-:|
|Samantha(D)|1|
|Julia(A)|1|
|Maria(A)|1|
|Meera(S)|1|
|Ashely(P)|1|
|Ketty(P)|1|
|Christeen(P)|1|
|Jane(A)|1|
|Jenny(D)|1|
|Priya(S)|1|

### 2. 테이블2를 만든다.

각 직업별 빈도를 담은 문자열을 `GROUP BY occupation`과 `CONCAT('There are a total of ', COUNT(*), ' ', LOWER(occupation), 's.')`으로 구한 다음 `result` 열에 저장하자.  
그리고 테이블1과 테이블2를 구분하기 위해 테이블2에 해당하는 행은 전부 2를 가지는 `table_type` 열을 만든다.

```sql
SELECT 
    CONCAT('There are a total of ', COUNT(*), ' ', LOWER(occupation), 's.') AS result, 
    2 AS table_type 
FROM 
    occupations 
GROUP BY 
    occupation 
```

(출력)

|result|table_type|
|:-:|:-:|
|There are a total of 2 doctors.|2|
|There are a total of 3 actors.|2|
|There are a total of 3 professors.|2|
|There are a total of 2 singers.|2|

### 3. 테이블1과 테이블2를 결합하여 정렬한다.

`UNION`을 이용하여 테이블1과 테이블2를 열 방향으로 결합한 후, `table_type`과 `reulst`를 기준으로 오름차순 정렬한다.  
단, 정렬 순서는 `table_type`, `result` 순이다.  
이러한 정렬 순서 때문에 테이블1, 테이블2의 순서대로 결과값이 출력되고 각 테이블 안에서 알파벳 순서대로 정렬된다.

```sql
SELECT 
    result 
FROM (
    SELECT 
        CONCAT(name, '(', LEFT(occupation, 1), ')') AS result, 
        1 AS table_type 
    FROM 
        occupations 
    UNION 
    SELECT 
        CONCAT('There are a total of ', COUNT(*), ' ', LOWER(occupation), 's.') AS result, 
        2 AS table_type 
    FROM 
        occupations 
    GROUP BY 
        occupation 
    ) AS sub
ORDER BY 
    table_type, result
```

<br><br><br><br>

## 풀이

```sql
SELECT 
    result 
FROM (
    SELECT 
        CONCAT(name, '(', LEFT(occupation, 1), ')') AS result, 
        1 AS table_type 
    FROM 
        occupations 
    UNION 
    SELECT 
        CONCAT('There are a total of ', COUNT(*), ' ', LOWER(occupation), 's.') AS result, 
        2 AS table_type 
    FROM 
        occupations 
    GROUP BY 
        occupation 
    ) AS sub
ORDER BY 
    table_type, result
```