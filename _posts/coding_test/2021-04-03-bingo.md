---
title: "[프로그래머스] 빙고"
categories: 
    - 코딩테스트
tags: 
    - 프로그래머스
    - 완전탐색
toc: true
toc_sticky: true
toc_label: "목차"
---

## 문제 설명

빙고는 N x N 크기의 게임 보드 칸에 1 부터 N x N 까지의 자연수를 중복 없이 하나씩 적은 후 숫자를 하나씩 지워나가는 게임입니다.  
이때, 가로, 세로, 대각선 방향으로 한 줄에 적힌 숫자를 모두 지울 경우 빙고를 1개 만들었다고 합니다.  
다음은 4 X 4 크기의 게임 보드를 이용해 게임을 진행한 예시입니다.  

![그림1](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/ee77e784-9b6e-451d-aa61-8da24fa49ce6/%E1%84%87%E1%85%B5%E1%86%BC%E1%84%80%E1%85%A92_rlkqli.png)  

위와 같이 각 칸에 숫자가 적혀 있을 때, 위 게임 보드에서 순서대로 지운 숫자가 [14, 3, 2, 4, 13, 1, 16, 11, 5, 15]인 경우 아래와 같이 빙고 3개가 만들어집니다.  

![그림2](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/f28064ab-b5fc-4d60-a385-d41202dd959a/%E1%84%87%E1%85%B5%E1%86%BC%E1%84%80%E1%85%A9_xibpii.png)  

빙고 게임 보드에 적힌 숫자가 담겨있는 배열 `board`, 게임 보드에서 순서대로 지운 숫자가 들어있는 배열 `nums` 가 매개변수로 주어질 때, `board` 에서 `nums` 에 들어있는 숫자를 모두 지우면 몇 개의 빙고가 만들어지는지 return 하도록 `solution` 함수를 완성해 주세요.

## 제한사항

- `board` 는 게임 보드 칸에 적힌 숫자를 뜻하는 NxN크기의 2차원 배열이며, N은 2 이상 500이하의 자연수입니다.
- `board` 의 각 칸에는 1 이상 N x N 이하의 자연수가 중복 없이 하나씩 들어있습니다.
- `nums` 는 `board` 에서 지울 숫자가 들어있는 배열이며, 길이는 1 이상 NxN이하입니다.
- `nums` 에 들어있는 숫자는 1 이상 N x N 이하의 자연수이며, 중복된 수가 들어있지 않습니다.

## 입출력 예

|board|nums|return|
|-----|----|------|
|`[[11, 13, 15, 16], [12, 1, 4, 3], [10, 2, 7, 8], [5, 14, 6, 9]]`|`[14, 3, 2, 4, 13, 1, 16, 11, 5, 15]`|`3`|
|`[[6, 15, 17, 14, 23], [5, 12, 16, 13, 25], [21, 4, 2, 1, 22], [10, 20, 3, 18, 8], [11, 9, 19, 24, 7]]`|`[15, 7, 2, 25, 9, 16, 12, 18, 5, 4, 10, 13, 20]`|`2`|

## 입출력 예 설명

- 입출력 예 #1

문제의 예시와 같습니다.

- 입출력 예 #2

다음 그림과 같이 2개의 빙고가 만들어집니다.  

![그림3](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/965fce23-debf-4151-aae7-e20c24f88849/%E1%84%87%E1%85%B5%E1%86%BC%E1%84%80%E1%85%A93_l1bqza.png)

## 풀이 1

```python
def solution(board, nums):
    N = len(board)
    nums = set(nums)
    answer = 0
    
    for i in range(N):
        if set(board[i]) <= nums: # 가로
            answer += 1
        if {b[i] for b in board} <= nums: # 세로
            answer += 1
    
    if {b[i] for i, b in enumerate(board)} <= nums: # 대각선 1
        answer += 1
    
    if {b[i] for i, b in zip(reversed(range(N)), board)} <= nums: # 대각선 2
        answer += 1
    
    return answer
```

## 풀이 2

```python
def solution(board, nums):
    N = len(board)
    nums = set(nums)
    answer = 0

    for i in range(N):
        for j in range(N):
            if board[i][j] in nums:
                board[i][j] = 0

    answer += len([b for b in board if sum(b) == 0])
    answer += len([b for b in zip(*board) if sum(b) == 0])
    answer += int(sum(board[i][i] for i in range(N)) == 0)
    answer += int(sum(board[N - 1 - i][i] for i in range(N)) == 0)

    return answer
```