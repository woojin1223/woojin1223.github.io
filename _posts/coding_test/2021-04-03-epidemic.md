---
title: "[프로그래머스] 전염병"
categories: 
    - 코딩테스트
tags: 
    - 프로그래머스
    - BFS
    - 큐
toc: true
toc_sticky: true
toc_label: "목차"
---

## 문제 설명

m x n 크기인 사무실이 있습니다.  
사무실에는 전염병에 걸린 직원이 있는데, 이 직원은 매일 상하좌우로 병을 퍼트려 다른 직원을 감염시킵니다.  
단, 백신을 접종한 직원은 면역력이 있어 감염되지 않습니다.  

예를 들어 2 x 4 크기 사무실에서, 병에 걸린 직원의 위치가 (1, 4), (2, 2)이고 백신을 맞은 직원의 위치가 (1, 2)입니다.  
이때 백신을 맞은 직원을 제외한 모든 직원이 병에 감염되기 까지는 이틀이 소요됩니다.  

0일  

![그림1](https://grepp-programmers.s3.amazonaws.com/files/production/9c4fb28f8a/efffcfc1-f803-46fc-b3fd-54169a20600b.png)  

1일  

![그림2](https://grepp-programmers.s3.amazonaws.com/files/production/9fdf14b30f/178463e2-09ad-46ae-a4d9-571572271946.png)  

2일  

![그림3](https://grepp-programmers.s3.amazonaws.com/files/production/49d73ec1ca/4cc4355f-407c-4d26-b1d6-87ba7f374a65.png)  

사무실의 크기 `m`, `n`과 병에 걸린 직원의 위치 `infests`, 백신을 맞은 직원의 위치 `vaccinateds` 가 매개변수로 주어집니다.  
이때 **백신을 맞은 직원을 제외한 모든 직원이 병에 감염되기까지 며칠이 걸리는지** return 하는 `solution` 함수를 완성해주세요.

## 제한사항

- `m`과 `n`은 1 이상 300 이하인 자연수입니다.
- `infests` 의 길이는 1 이상 `m` * `n` 이하입니다.
    + `infests` 의 원소는 `[a, b]` 형식이며, 1 ≤ a ≤ m, 1 ≤ b ≤ n입니다.
    + `infests` 에는 같은 원소가 두 번 이상 들어있지 않습니다.
- `vaccinateds` 는 길이가 1 이상 m * n 이하입니다.
    + `vaccinateds` 의 원소는 `[a, b]` 형식이며, 1 ≤ a ≤ m, 1 ≤ b ≤ n입니다.
    + `vaccinateds` 에는 같은 원소가 두 번 이상 들어있지 않습니다.
- 백신을 맞은 직원이 병에 걸린 경우는 주어지지 않습니다.
- 병을 아무리 퍼트려도 백신을 맞은 직원을 제외한 모든 직원이 병에 감염될 수 없다면 -1을 리턴합니다.

## 입출력 예

|m|n|infests|vaccinateds|return|
|-|-|-------|-----------|------|
|`2`|`4`|`[[1, 4], [2, 2]]`|`[[1, 2]]`|`2`|
|`2`|`3`|`[[2, 2]]`|`[[1, 2], [2, 1], [2, 3]]`|`-1`|
|`2`|`2`|`[[1, 1], [2, 2]]`|`[[1, 2], [2, 1]]`|`0`|

## 입출력 예에 대한 설명

- 입출력 예 #1

문제의 예시와 같습니다.

- 입출력 예 #2

![그림4](https://grepp-programmers.s3.amazonaws.com/files/production/931ce64a33/486ea8a6-4d6f-45b1-9af2-35e36e049326.png)  

전염병자의 근처가 백신 접종자로 막혀있어, 다른 직원에게 병이 도달하지 않습니다.  
따라서 -1을 리턴합니다.

- 입출력 예 #3

![그림5](https://grepp-programmers.s3.amazonaws.com/files/production/93d4ee8842/77ec17c9-949f-4ccb-bf11-2c3010a2f9a8.png)  

처음부터 모든 직원이 전염병을 앓고 있거나, 백신을 맞은 상태입니다.  
따라서 0을 리턴합니다.

## 풀이

```python
from collections import deque
from itertools import chain

def solution(m, n, infests, vaccinateds):
    infested = [[0] * n for _ in range(m)]

    for i in infests:
        infested[i[0] - 1][i[1] - 1] = 1

    for v in vaccinateds:
        infested[v[0] - 1][v[1] - 1] = 1
    
    queue = deque([infests])
    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    count = 0

    while queue:
        new_infest = []
        infest = queue.popleft()

        for i in infest:
            x, y = i

            for dx, dy in dirs:
                nx, ny = x + dx - 1, y + dy - 1

                if nx < 0 or nx >= m or ny < 0 or ny >= n:
                    continue

                if infested[nx][ny] == 1:
                    continue

                infested[nx][ny] = 1
                new_infest.append((nx + 1, ny + 1))
        
        if new_infest:
            queue.append(new_infest)
            count += 1
        elif sum(chain(*infested)) != m * n:
            return -1

    return count
```