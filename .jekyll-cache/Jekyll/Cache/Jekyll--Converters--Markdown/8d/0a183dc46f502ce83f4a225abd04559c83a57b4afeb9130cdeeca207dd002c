I"?<h2 id="문제-링크">문제 링크</h2>

<p><a href="https://www.hackerrank.com/challenges/binary-search-tree-1/problem">https://www.hackerrank.com/challenges/binary-search-tree-1/problem</a></p>

<p><br /><br /><br /><br /></p>

<h2 id="테이블-설명">테이블 설명</h2>

<h3 id="bst"><code class="language-html highlighter-rouge">BST</code></h3>

<p>이진트리는 각각의 노드의 자식이 최대 두 개인 트리 자료 구조이다.<br />
<code class="language-html highlighter-rouge">BST</code>는 (자식 노드, 부모 노드) 형태의 행을 가지는 2열로 구성된 테이블이다.<br />
테이블 <code class="language-html highlighter-rouge">BST</code>의 예시는 다음과 같다.</p>

<p>(열 설명)</p>

<ul>
  <li><code class="language-html highlighter-rouge">N</code>: 자식 노드의 번호에 해당한다.</li>
  <li><code class="language-html highlighter-rouge">P</code>: 부모 노드의 번호에 해당한다.</li>
</ul>

<p>(예시)</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">N</th>
      <th style="text-align: center">P</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: center">8</td>
    </tr>
    <tr>
      <td style="text-align: center">9</td>
      <td style="text-align: center">8</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center">8</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">null</td>
    </tr>
  </tbody>
</table>

<p><br /><br /><br /><br /></p>

<h2 id="문제-설명">문제 설명</h2>

<p>위 테이블 <code class="language-html highlighter-rouge">BST</code>를 이진트리 그림으로 나타내면 아래와 같다.</p>

<p><img src="https://s3.amazonaws.com/hr-challenge-images/12888/1443773633-f9e6fd314e-simply_sql_bst.png" alt="binary_tree_nodes" /></p>

<p>위와 같은 이진트리 구조에서 Root node, Leaf node, Inner node를 찾는 문제다.</p>

<ul>
  <li>Root node: 부모 노드가 없는 노드를 말하며, 그림에서는 5번 노드가 이에 해당한다.</li>
  <li>Leaf node: 자식 노드가 없는 노드를 말하며, 그림에서는 1번, 3번, 6번, 9번 노드가 이에 해당한다.</li>
  <li>Inner node: Root node와 Leaf node가 아닌 노드를 말하며, 그림에서는 2번, 8번 노드가 이에 해당한다.</li>
</ul>

<p>단, 노드 번호를 기준으로 오름차순 정렬해야 한다.</p>

<p><br /><br /><br /><br /></p>

<h2 id="사고-과정">사고 과정</h2>

<h3 id="1-root-node에-해당하는-테이블을-구한다">1. Root node에 해당하는 테이블을 구한다.</h3>

<p>Root node는 부모 노드가 없는 노드다.<br />
즉, <code class="language-html highlighter-rouge">WHERE p IS NULL</code>을 이용하여 Root node를 구할 수 있다.</p>

<p>(SQL 코드)</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="base16.solarized"><code><span class="k">SELECT</span> 
    <span class="n">n</span><span class="p">,</span> 
    <span class="s1">'Root'</span> <span class="k">AS</span> <span class="n">node_type</span> 
<span class="k">FROM</span> 
    <span class="n">bst</span> 
<span class="k">WHERE</span> 
    <span class="n">p</span> <span class="k">IS</span> <span class="k">NULL</span>
</code></pre></div></div>

<p>(실행 결과)</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">n</th>
      <th style="text-align: center">node_type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">Root</td>
    </tr>
  </tbody>
</table>

<h3 id="2-inner-node에-해당하는-테이블을-구한다">2. Inner node에 해당하는 테이블을 구한다.</h3>

<p>Inner node는 부모 노드 집합 중에서 Root node가 아닌 노드다.<br />
1.의 쿼리 결과를 임시 테이블 <code class="language-html highlighter-rouge">root_node</code>에 저장했다고 가정하자.<br />
부모 노드 집합을 구하는 쿼리 <code class="language-html highlighter-rouge">SELECT DISTINCT p FROM bst WHERE p IS NOT NULL</code>에서 Root node가 아닌 노드를 구하는 WHERE 절 <code class="language-html highlighter-rouge">WHERE p != (SELECT n FROM root_node)</code>을 추가하여 Inner node를 구할 수 있다.</p>

<p>(SQL 코드)</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="base16.solarized"><code><span class="k">SELECT</span> 
    <span class="k">DISTINCT</span> <span class="n">p</span> <span class="k">AS</span> <span class="n">n</span><span class="p">,</span> 
    <span class="s1">'Inner'</span>    <span class="k">AS</span> <span class="n">node_type</span> 
<span class="k">FROM</span> 
    <span class="n">bst</span> 
<span class="k">WHERE</span> 
    <span class="n">p</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">AND</span> 
    <span class="n">p</span> <span class="o">!=</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">n</span> <span class="k">FROM</span> <span class="n">root_node</span><span class="p">)</span>
</code></pre></div></div>

<p>(실행 결과)</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">n</th>
      <th style="text-align: center">node_type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">Inner</td>
    </tr>
    <tr>
      <td style="text-align: center">8</td>
      <td style="text-align: center">Inner</td>
    </tr>
  </tbody>
</table>

<h3 id="3-leaf-node에-해당하는-테이블을-구한다">3. Leaf node에 해당하는 테이블을 구한다.</h3>

<p>Leaf node는 Root node와 Inner node가 아닌 노드다.<br />
1.의 쿼리 결과를 임시 테이블 <code class="language-html highlighter-rouge">root_node</code>, 2.의 쿼리 결과를 임시 테이블 <code class="language-html highlighter-rouge">inner_node</code>에 저장했다고 가정하자.<br />
Root node와 Inner node가 아닌 노드를 구하는 WHERE 절 <code class="language-html highlighter-rouge">WHERE n NOT IN (SELECT n FROM root_node UNION SELECT n FROM inner_node)</code>을 추가하여 Leaf node를 구할 수 있다.</p>

<p>(SQL 코드)</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="base16.solarized"><code><span class="k">SELECT</span> 
    <span class="n">n</span><span class="p">,</span> 
    <span class="s1">'Leaf'</span> <span class="k">AS</span> <span class="n">node_type</span> 
<span class="k">FROM</span> 
    <span class="n">bst</span> 
<span class="k">WHERE</span> 
    <span class="n">n</span> <span class="k">NOT</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">n</span> <span class="k">FROM</span> <span class="n">root_node</span> <span class="k">UNION</span> <span class="k">SELECT</span> <span class="n">n</span> <span class="k">FROM</span> <span class="n">inner_node</span><span class="p">)</span>
</code></pre></div></div>

<p>(실행 결과)</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">n</th>
      <th style="text-align: center">node_type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">Leaf</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">Leaf</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: center">Leaf</td>
    </tr>
    <tr>
      <td style="text-align: center">9</td>
      <td style="text-align: center">Leaf</td>
    </tr>
  </tbody>
</table>

<h3 id="4-위-세-개의-테이블을-union을-이용하여-세로-방향으로-결합한-후-노드-번호를-기준으로-오름차순-정렬한다">4. 위 세 개의 테이블을 <code class="language-html highlighter-rouge">UNION</code>을 이용하여 세로 방향으로 결합한 후, 노드 번호를 기준으로 오름차순 정렬한다.</h3>

<p>WITH 절을 이용하여 1.에서 구한 Root node를 임시 테이블 <code class="language-html highlighter-rouge">root_node</code>에 저장하고 2.에서 구한 Inner node는 임시 테이블 <code class="language-html highlighter-rouge">inner_node</code>에 저장하고 3.에서 구한 Leaf node를 임시 테이블 <code class="language-html highlighter-rouge">leaf_node</code>에 저장하자.</p>

<p>(SQL 코드)</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="base16.solarized"><code><span class="k">WITH</span> <span class="n">root_node</span> <span class="k">AS</span> <span class="p">(</span>
    <span class="k">SELECT</span> 
        <span class="n">n</span><span class="p">,</span> 
        <span class="s1">'Root'</span> <span class="k">AS</span> <span class="n">node_type</span> 
    <span class="k">FROM</span> 
        <span class="n">bst</span> 
    <span class="k">WHERE</span> 
        <span class="n">p</span> <span class="k">IS</span> <span class="k">NULL</span>
<span class="p">),</span> <span class="n">inner_node</span> <span class="k">AS</span> <span class="p">(</span>
    <span class="k">SELECT</span> 
        <span class="k">DISTINCT</span> <span class="n">p</span> <span class="k">AS</span> <span class="n">n</span><span class="p">,</span> 
        <span class="s1">'Inner'</span>    <span class="k">AS</span> <span class="n">node_type</span> 
    <span class="k">FROM</span> 
        <span class="n">bst</span> 
    <span class="k">WHERE</span> 
        <span class="n">p</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">AND</span> 
        <span class="n">p</span> <span class="o">!=</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">n</span> <span class="k">FROM</span> <span class="n">root_node</span><span class="p">)</span>
<span class="p">),</span> <span class="n">leaf_node</span> <span class="k">AS</span> <span class="p">(</span>
    <span class="k">SELECT</span> 
        <span class="n">n</span><span class="p">,</span> 
        <span class="s1">'Leaf'</span> <span class="k">AS</span> <span class="n">node_type</span> 
    <span class="k">FROM</span> 
        <span class="n">bst</span> 
    <span class="k">WHERE</span> 
        <span class="n">n</span> <span class="k">NOT</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">n</span> <span class="k">FROM</span> <span class="n">root_node</span> <span class="k">UNION</span> <span class="k">SELECT</span> <span class="n">n</span> <span class="k">FROM</span> <span class="n">inner_node</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div></div>

<p>그 후에 <code class="language-html highlighter-rouge">UNION</code>을 이용하여 세 개의 임시 테이블 <code class="language-html highlighter-rouge">root_node</code>, <code class="language-html highlighter-rouge">inner_node</code>, <code class="language-html highlighter-rouge">leaf_node</code>을 세로 방향으로 결합한 후, 노드 번호를 기준으로 오름차순 정렬한다.</p>

<p>(SQL 코드)</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="base16.solarized"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">root_node</span> 
<span class="k">UNION</span> 
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">inner_node</span> 
<span class="k">UNION</span> 
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">leaf_node</span> 
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">n</span>
</code></pre></div></div>

<p>(실행 결과)</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">n</th>
      <th style="text-align: center">node_type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">Leaf</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">Inner</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">Leaf</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">Root</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: center">Leaf</td>
    </tr>
    <tr>
      <td style="text-align: center">8</td>
      <td style="text-align: center">Inner</td>
    </tr>
    <tr>
      <td style="text-align: center">9</td>
      <td style="text-align: center">Leaf</td>
    </tr>
  </tbody>
</table>

<p><br /><br /><br /><br /></p>

<h2 id="풀이">풀이</h2>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="base16.solarized"><code><span class="c1">-- WITH 절로 임시 테이블 root_node, inner_node, leaf_node 생성</span>
<span class="k">WITH</span> <span class="n">root_node</span> <span class="k">AS</span> <span class="p">(</span>
    <span class="k">SELECT</span> 
        <span class="n">n</span><span class="p">,</span> 
        <span class="s1">'Root'</span> <span class="k">AS</span> <span class="n">node_type</span> 
    <span class="k">FROM</span> 
        <span class="n">bst</span> 
    <span class="k">WHERE</span> 
        <span class="n">p</span> <span class="k">IS</span> <span class="k">NULL</span>
<span class="p">),</span> <span class="n">inner_node</span> <span class="k">AS</span> <span class="p">(</span>
    <span class="k">SELECT</span> 
        <span class="k">DISTINCT</span> <span class="n">p</span> <span class="k">AS</span> <span class="n">n</span><span class="p">,</span> 
        <span class="s1">'Inner'</span>    <span class="k">AS</span> <span class="n">node_type</span> 
    <span class="k">FROM</span> 
        <span class="n">bst</span> 
    <span class="k">WHERE</span> 
        <span class="n">p</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">AND</span> 
        <span class="n">p</span> <span class="o">!=</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">n</span> <span class="k">FROM</span> <span class="n">root_node</span><span class="p">)</span>
<span class="p">),</span> <span class="n">leaf_node</span> <span class="k">AS</span> <span class="p">(</span>
    <span class="k">SELECT</span> 
        <span class="n">n</span><span class="p">,</span> 
        <span class="s1">'Leaf'</span> <span class="k">AS</span> <span class="n">node_type</span> 
    <span class="k">FROM</span> 
        <span class="n">bst</span> 
    <span class="k">WHERE</span> 
        <span class="n">n</span> <span class="k">NOT</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">n</span> <span class="k">FROM</span> <span class="n">root_node</span> <span class="k">UNION</span> <span class="k">SELECT</span> <span class="n">n</span> <span class="k">FROM</span> <span class="n">inner_node</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1">-- UNION으로 root_node, inner_node, leaf_node 결합 후 정렬</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">root_node</span> 
<span class="k">UNION</span> 
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">inner_node</span> 
<span class="k">UNION</span> 
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">leaf_node</span> 
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">n</span>
</code></pre></div></div>
:ET